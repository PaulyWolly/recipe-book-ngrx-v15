{"ast":null,"code":"import { createAction, props, select, Store, createSelector } from '@ngrx/store';\nimport { InjectionToken, NgModule, ErrorHandler, Inject } from '@angular/core';\nimport { NavigationStart, RoutesRecognized, NavigationCancel, NavigationError, NavigationEnd, Router } from '@angular/router';\nimport { withLatestFrom } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/actions.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * An action dispatched when a router navigation request is fired.\n * @type {?}\n */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@ngrx/store';\nimport * as ɵngcc2 from '@angular/router';\nconst ROUTER_REQUEST = '@ngrx/router-store/request';\n/** @type {?} */\nconst routerRequestAction = createAction(ROUTER_REQUEST, props());\n/**\n * An action dispatched when the router navigates.\n * @type {?}\n */\nconst ROUTER_NAVIGATION = '@ngrx/router-store/navigation';\n/** @type {?} */\nconst routerNavigationAction = createAction(ROUTER_NAVIGATION, props());\n/**\n * An action dispatched when the router cancels navigation.\n * @type {?}\n */\nconst ROUTER_CANCEL = '@ngrx/router-store/cancel';\n/** @type {?} */\nconst routerCancelAction = createAction(ROUTER_CANCEL, props());\n/**\n * An action dispatched when the router errors.\n * @type {?}\n */\nconst ROUTER_ERROR = '@ngrx/router-store/error';\n/** @type {?} */\nconst routerErrorAction = createAction(ROUTER_ERROR, props());\n/**\n * An action dispatched after navigation has ended and new route is active.\n * @type {?}\n */\nconst ROUTER_NAVIGATED = '@ngrx/router-store/navigated';\n/** @type {?} */\nconst routerNavigatedAction = createAction(ROUTER_NAVIGATED, props());\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/reducer.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template T\n * @param {?} state\n * @param {?} action\n * @return {?}\n */\nfunction routerReducer(state, action) {\n  // Allow compilation with strictFunctionTypes - ref: #1344\n  /** @type {?} */\n  const routerAction = /** @type {?} */action;\n  switch (routerAction.type) {\n    case ROUTER_NAVIGATION:\n    case ROUTER_ERROR:\n    case ROUTER_CANCEL:\n      return {\n        state: routerAction.payload.routerState,\n        navigationId: routerAction.payload.event.id\n      };\n    default:\n      return (/** @type {?} */state\n      );\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/serializers/base.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Simple router state.\n * All custom router states / state serializers should have at least\n * the properties of this interface.\n * @record\n */\nfunction BaseRouterStoreState() {}\nif (false) {\n  /** @type {?} */\n  BaseRouterStoreState.prototype.url;\n}\n/**\n * @abstract\n * @template T\n */\nclass RouterStateSerializer {}\nif (false) {\n  /**\n   * @abstract\n   * @param {?} routerState\n   * @return {?}\n   */\n  RouterStateSerializer.prototype.serialize = function (routerState) {};\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/serializers/default_serializer.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @record\n */\nfunction SerializedRouterStateSnapshot() {}\nif (false) {\n  /** @type {?} */\n  SerializedRouterStateSnapshot.prototype.root;\n  /** @type {?} */\n  SerializedRouterStateSnapshot.prototype.url;\n}\nclass DefaultRouterStateSerializer {\n  /**\n   * @param {?} routerState\n   * @return {?}\n   */\n  serialize(routerState) {\n    return {\n      root: this.serializeRoute(routerState.root),\n      url: routerState.url\n    };\n  }\n  /**\n   * @private\n   * @param {?} route\n   * @return {?}\n   */\n  serializeRoute(route) {\n    /** @type {?} */\n    const children = route.children.map(\n    /**\n    * @param {?} c\n    * @return {?}\n    */\n    c => this.serializeRoute(c));\n    return {\n      params: route.params,\n      paramMap: route.paramMap,\n      data: route.data,\n      url: route.url,\n      outlet: route.outlet,\n      routeConfig: route.routeConfig ? {\n        component: route.routeConfig.component,\n        path: route.routeConfig.path,\n        pathMatch: route.routeConfig.pathMatch,\n        redirectTo: route.routeConfig.redirectTo,\n        outlet: route.routeConfig.outlet\n      } : null,\n      queryParams: route.queryParams,\n      queryParamMap: route.queryParamMap,\n      fragment: route.fragment,\n      component: /** @type {?} */route.routeConfig ? route.routeConfig.component : undefined,\n      root: /** @type {?} */undefined,\n      parent: /** @type {?} */undefined,\n      firstChild: children[0],\n      pathFromRoot: /** @type {?} */undefined,\n      children\n    };\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/serializers/minimal_serializer.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @record\n */\nfunction MinimalActivatedRouteSnapshot() {}\nif (false) {\n  /** @type {?} */\n  MinimalActivatedRouteSnapshot.prototype.routeConfig;\n  /** @type {?} */\n  MinimalActivatedRouteSnapshot.prototype.url;\n  /** @type {?} */\n  MinimalActivatedRouteSnapshot.prototype.params;\n  /** @type {?} */\n  MinimalActivatedRouteSnapshot.prototype.queryParams;\n  /** @type {?} */\n  MinimalActivatedRouteSnapshot.prototype.fragment;\n  /** @type {?} */\n  MinimalActivatedRouteSnapshot.prototype.data;\n  /** @type {?} */\n  MinimalActivatedRouteSnapshot.prototype.outlet;\n  /** @type {?|undefined} */\n  MinimalActivatedRouteSnapshot.prototype.firstChild;\n  /** @type {?} */\n  MinimalActivatedRouteSnapshot.prototype.children;\n}\n/**\n * @record\n */\nfunction MinimalRouterStateSnapshot() {}\nif (false) {\n  /** @type {?} */\n  MinimalRouterStateSnapshot.prototype.root;\n  /** @type {?} */\n  MinimalRouterStateSnapshot.prototype.url;\n}\nclass MinimalRouterStateSerializer {\n  /**\n   * @param {?} routerState\n   * @return {?}\n   */\n  serialize(routerState) {\n    return {\n      root: this.serializeRoute(routerState.root),\n      url: routerState.url\n    };\n  }\n  /**\n   * @private\n   * @param {?} route\n   * @return {?}\n   */\n  serializeRoute(route) {\n    /** @type {?} */\n    const children = route.children.map(\n    /**\n    * @param {?} c\n    * @return {?}\n    */\n    c => this.serializeRoute(c));\n    return {\n      params: route.params,\n      data: route.data,\n      url: route.url,\n      outlet: route.outlet,\n      routeConfig: route.routeConfig ? {\n        path: route.routeConfig.path,\n        pathMatch: route.routeConfig.pathMatch,\n        redirectTo: route.routeConfig.redirectTo,\n        outlet: route.routeConfig.outlet\n      } : null,\n      queryParams: route.queryParams,\n      fragment: route.fragment,\n      firstChild: children[0],\n      children\n    };\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/router_store_module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @enum {number} */\nconst RouterState = {\n  Full: 0,\n  Minimal: 1\n};\n/**\n * @record\n * @template T\n */\nfunction StoreRouterConfig() {}\nif (false) {\n  /** @type {?|undefined} */\n  StoreRouterConfig.prototype.stateKey;\n  /** @type {?|undefined} */\n  StoreRouterConfig.prototype.serializer;\n  /**\n   * By default, ROUTER_NAVIGATION is dispatched before guards and resolvers run.\n   * Therefore, the action could run too soon, for example\n   * there may be a navigation cancel due to a guard saying the navigation is not allowed.\n   * To run ROUTER_NAVIGATION after guards and resolvers,\n   * set this property to NavigationActionTiming.PostActivation.\n   * @type {?|undefined}\n   */\n  StoreRouterConfig.prototype.navigationActionTiming;\n  /**\n   * Decides which router serializer should be used, if there is none provided, and the metadata on the dispatched \\@ngrx/router-store action payload.\n   * Set to `Full` to use the `DefaultRouterStateSerializer` and to set the angular router events as payload.\n   * Set to `Minimal` to use the `MinimalRouterStateSerializer` and to set a minimal router event with the navigation id and url as payload.\n   * @type {?|undefined}\n   */\n  StoreRouterConfig.prototype.routerState;\n}\n/**\n * @record\n */\nfunction StoreRouterActionPayload() {}\nif (false) {\n  /** @type {?} */\n  StoreRouterActionPayload.prototype.event;\n  /** @type {?|undefined} */\n  StoreRouterActionPayload.prototype.routerState;\n  /** @type {?|undefined} */\n  StoreRouterActionPayload.prototype.storeState;\n}\n/** @enum {number} */\nconst NavigationActionTiming = {\n  PreActivation: 1,\n  PostActivation: 2\n};\nNavigationActionTiming[NavigationActionTiming.PreActivation] = 'PreActivation';\nNavigationActionTiming[NavigationActionTiming.PostActivation] = 'PostActivation';\n/** @type {?} */\nconst _ROUTER_CONFIG = new InjectionToken('@ngrx/router-store Internal Configuration');\n/** @type {?} */\nconst ROUTER_CONFIG = new InjectionToken('@ngrx/router-store Configuration');\n/** @type {?} */\nconst DEFAULT_ROUTER_FEATURENAME = 'router';\n/**\n * @param {?} config\n * @return {?}\n */\nfunction _createRouterConfig(config) {\n  return Object.assign({\n    stateKey: DEFAULT_ROUTER_FEATURENAME,\n    serializer: MinimalRouterStateSerializer,\n    navigationActionTiming: NavigationActionTiming.PreActivation\n  }, config);\n}\n/** @enum {number} */\nconst RouterTrigger = {\n  NONE: 1,\n  ROUTER: 2,\n  STORE: 3\n};\nRouterTrigger[RouterTrigger.NONE] = 'NONE';\nRouterTrigger[RouterTrigger.ROUTER] = 'ROUTER';\nRouterTrigger[RouterTrigger.STORE] = 'STORE';\n/**\n * Connects RouterModule with StoreModule.\n *\n * During the navigation, before any guards or resolvers run, the router will dispatch\n * a ROUTER_NAVIGATION action, which has the following signature:\n *\n * ```\n * export type RouterNavigationPayload = {\n *   routerState: SerializedRouterStateSnapshot,\n *   event: RoutesRecognized\n * }\n * ```\n *\n * Either a reducer or an effect can be invoked in response to this action.\n * If the invoked reducer throws, the navigation will be canceled.\n *\n * If navigation gets canceled because of a guard, a ROUTER_CANCEL action will be\n * dispatched. If navigation results in an error, a ROUTER_ERROR action will be dispatched.\n *\n * Both ROUTER_CANCEL and ROUTER_ERROR contain the store state before the navigation\n * which can be used to restore the consistency of the store.\n *\n * Usage:\n *\n * ```typescript\n * \\@NgModule({\n *   declarations: [AppCmp, SimpleCmp],\n *   imports: [\n *     BrowserModule,\n *     StoreModule.forRoot(mapOfReducers),\n *     RouterModule.forRoot([\n *       { path: '', component: SimpleCmp },\n *       { path: 'next', component: SimpleCmp }\n *     ]),\n *     StoreRouterConnectingModule.forRoot()\n *   ],\n *   bootstrap: [AppCmp]\n * })\n * export class AppModule {\n * }\n * ```\n */\nlet StoreRouterConnectingModule = /*#__PURE__*/(() => {\n  class StoreRouterConnectingModule {\n    /**\n     * @param {?} store\n     * @param {?} router\n     * @param {?} serializer\n     * @param {?} errorHandler\n     * @param {?} config\n     */\n    constructor(store, router, serializer, errorHandler, config) {\n      this.store = store;\n      this.router = router;\n      this.serializer = serializer;\n      this.errorHandler = errorHandler;\n      this.config = config;\n      this.lastEvent = null;\n      this.routerState = null;\n      this.trigger = RouterTrigger.NONE;\n      this.stateKey = /** @type {?} */this.config.stateKey;\n      this.setUpStoreStateListener();\n      this.setUpRouterEventsListener();\n    }\n    /**\n     * @template T\n     * @param {?=} config\n     * @return {?}\n     */\n    static forRoot(config = {}) {\n      return {\n        ngModule: StoreRouterConnectingModule,\n        providers: [{\n          provide: _ROUTER_CONFIG,\n          useValue: config\n        }, {\n          provide: ROUTER_CONFIG,\n          useFactory: _createRouterConfig,\n          deps: [_ROUTER_CONFIG]\n        }, {\n          provide: RouterStateSerializer,\n          useClass: config.serializer ? config.serializer : config.routerState === 0 /* Full */ ? DefaultRouterStateSerializer : MinimalRouterStateSerializer\n        }]\n      };\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    setUpStoreStateListener() {\n      this.store.pipe(select( /** @type {?} */this.stateKey), withLatestFrom(this.store)).subscribe(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      ([routerStoreState, storeState]) => {\n        this.navigateIfNeeded(routerStoreState, storeState);\n      });\n    }\n    /**\n     * @private\n     * @param {?} routerStoreState\n     * @param {?} storeState\n     * @return {?}\n     */\n    navigateIfNeeded(routerStoreState, storeState) {\n      if (!routerStoreState || !routerStoreState.state) {\n        return;\n      }\n      if (this.trigger === RouterTrigger.ROUTER) {\n        return;\n      }\n      if (this.lastEvent instanceof NavigationStart) {\n        return;\n      }\n      /** @type {?} */\n      const url = routerStoreState.state.url;\n      if (!isSameUrl(this.router.url, url)) {\n        this.storeState = storeState;\n        this.trigger = RouterTrigger.STORE;\n        this.router.navigateByUrl(url).catch(\n        /**\n        * @param {?} error\n        * @return {?}\n        */\n        error => {\n          this.errorHandler.handleError(error);\n        });\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    setUpRouterEventsListener() {\n      /** @type {?} */\n      const dispatchNavLate = this.config.navigationActionTiming === NavigationActionTiming.PostActivation;\n      /** @type {?} */\n      let routesRecognized;\n      this.router.events.pipe(withLatestFrom(this.store)).subscribe(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      ([event, storeState]) => {\n        this.lastEvent = event;\n        if (event instanceof NavigationStart) {\n          this.routerState = this.serializer.serialize(this.router.routerState.snapshot);\n          if (this.trigger !== RouterTrigger.STORE) {\n            this.storeState = storeState;\n            this.dispatchRouterRequest(event);\n          }\n        } else if (event instanceof RoutesRecognized) {\n          routesRecognized = event;\n          if (!dispatchNavLate && this.trigger !== RouterTrigger.STORE) {\n            this.dispatchRouterNavigation(event);\n          }\n        } else if (event instanceof NavigationCancel) {\n          this.dispatchRouterCancel(event);\n          this.reset();\n        } else if (event instanceof NavigationError) {\n          this.dispatchRouterError(event);\n          this.reset();\n        } else if (event instanceof NavigationEnd) {\n          if (this.trigger !== RouterTrigger.STORE) {\n            if (dispatchNavLate) {\n              this.dispatchRouterNavigation(routesRecognized);\n            }\n            this.dispatchRouterNavigated(event);\n          }\n          this.reset();\n        }\n      });\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    dispatchRouterRequest(event) {\n      this.dispatchRouterAction(ROUTER_REQUEST, {\n        event\n      });\n    }\n    /**\n     * @private\n     * @param {?} lastRoutesRecognized\n     * @return {?}\n     */\n    dispatchRouterNavigation(lastRoutesRecognized) {\n      /** @type {?} */\n      const nextRouterState = this.serializer.serialize(lastRoutesRecognized.state);\n      this.dispatchRouterAction(ROUTER_NAVIGATION, {\n        routerState: nextRouterState,\n        event: new RoutesRecognized(lastRoutesRecognized.id, lastRoutesRecognized.url, lastRoutesRecognized.urlAfterRedirects, nextRouterState)\n      });\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    dispatchRouterCancel(event) {\n      this.dispatchRouterAction(ROUTER_CANCEL, {\n        storeState: this.storeState,\n        event\n      });\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    dispatchRouterError(event) {\n      this.dispatchRouterAction(ROUTER_ERROR, {\n        storeState: this.storeState,\n        event: new NavigationError(event.id, event.url, `${event}`)\n      });\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    dispatchRouterNavigated(event) {\n      /** @type {?} */\n      const routerState = this.serializer.serialize(this.router.routerState.snapshot);\n      this.dispatchRouterAction(ROUTER_NAVIGATED, {\n        event,\n        routerState\n      });\n    }\n    /**\n     * @private\n     * @param {?} type\n     * @param {?} payload\n     * @return {?}\n     */\n    dispatchRouterAction(type, payload) {\n      this.trigger = RouterTrigger.ROUTER;\n      try {\n        this.store.dispatch({\n          type,\n          payload: Object.assign(Object.assign({\n            routerState: this.routerState\n          }, payload), {\n            event: this.config.routerState === 0 /* Full */ ? payload.event : {\n              id: payload.event.id,\n              url: payload.event.url,\n              // safe, as it will just be `undefined` for non-NavigationEnd router events\n              urlAfterRedirects: /** @type {?} */payload.event.urlAfterRedirects\n            }\n          })\n        });\n      } finally {\n        this.trigger = RouterTrigger.NONE;\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    reset() {\n      this.trigger = RouterTrigger.NONE;\n      this.storeState = null;\n      this.routerState = null;\n    }\n  }\n  StoreRouterConnectingModule.ɵfac = function StoreRouterConnectingModule_Factory(t) {\n    return new (t || StoreRouterConnectingModule)(ɵngcc0.ɵɵinject(ɵngcc1.Store), ɵngcc0.ɵɵinject(ɵngcc2.Router), ɵngcc0.ɵɵinject(RouterStateSerializer), ɵngcc0.ɵɵinject(ɵngcc0.ErrorHandler), ɵngcc0.ɵɵinject(ROUTER_CONFIG));\n  };\n  StoreRouterConnectingModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: StoreRouterConnectingModule\n  });\n  StoreRouterConnectingModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  /** @nocollapse */\n  return StoreRouterConnectingModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  StoreRouterConnectingModule.prototype.lastEvent;\n  /**\n   * @type {?}\n   * @private\n   */\n  StoreRouterConnectingModule.prototype.routerState;\n  /**\n   * @type {?}\n   * @private\n   */\n  StoreRouterConnectingModule.prototype.storeState;\n  /**\n   * @type {?}\n   * @private\n   */\n  StoreRouterConnectingModule.prototype.trigger;\n  /**\n   * @type {?}\n   * @private\n   */\n  StoreRouterConnectingModule.prototype.stateKey;\n  /**\n   * @type {?}\n   * @private\n   */\n  StoreRouterConnectingModule.prototype.store;\n  /**\n   * @type {?}\n   * @private\n   */\n  StoreRouterConnectingModule.prototype.router;\n  /**\n   * @type {?}\n   * @private\n   */\n  StoreRouterConnectingModule.prototype.serializer;\n  /**\n   * @type {?}\n   * @private\n   */\n  StoreRouterConnectingModule.prototype.errorHandler;\n  /**\n   * @type {?}\n   * @private\n   */\n  StoreRouterConnectingModule.prototype.config;\n}\n/**\n * Check if the URLs are matching. Accounts for the possibility of trailing \"/\" in url.\n * @param {?} first\n * @param {?} second\n * @return {?}\n */\nfunction isSameUrl(first, second) {\n  return stripTrailingSlash(first) === stripTrailingSlash(second);\n}\n/**\n * @param {?} text\n * @return {?}\n */\nfunction stripTrailingSlash(text) {\n  if (text.length > 0 && text[text.length - 1] === '/') {\n    return text.substring(0, text.length - 1);\n  }\n  return text;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/router_selectors.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template V\n * @param {?} selectState\n * @return {?}\n */\nfunction getSelectors(selectState) {\n  /** @type {?} */\n  const selectRouterState = createSelector(selectState,\n  /**\n  * @param {?} router\n  * @return {?}\n  */\n  router => router && router.state);\n  /** @type {?} */\n  const selectCurrentRoute = createSelector(selectRouterState,\n  /**\n  * @param {?} routerState\n  * @return {?}\n  */\n  routerState => {\n    if (!routerState) {\n      return undefined;\n    }\n    /** @type {?} */\n    let route = routerState.root;\n    while (route.firstChild) {\n      route = route.firstChild;\n    }\n    return route;\n  });\n  /** @type {?} */\n  const selectFragment = createSelector(selectCurrentRoute,\n  /**\n  * @param {?} route\n  * @return {?}\n  */\n  route => route && route.fragment);\n  /** @type {?} */\n  const selectQueryParams = createSelector(selectCurrentRoute,\n  /**\n  * @param {?} route\n  * @return {?}\n  */\n  route => route && route.queryParams);\n  /** @type {?} */\n  const selectQueryParam =\n  /**\n  * @param {?} param\n  * @return {?}\n  */\n  param => createSelector(selectQueryParams,\n  /**\n  * @param {?} params\n  * @return {?}\n  */\n  params => params && params[param]);\n  /** @type {?} */\n  const selectRouteParams = createSelector(selectCurrentRoute,\n  /**\n  * @param {?} route\n  * @return {?}\n  */\n  route => route && route.params);\n  /** @type {?} */\n  const selectRouteParam =\n  /**\n  * @param {?} param\n  * @return {?}\n  */\n  param => createSelector(selectRouteParams,\n  /**\n  * @param {?} params\n  * @return {?}\n  */\n  params => params && params[param]);\n  /** @type {?} */\n  const selectRouteData = createSelector(selectCurrentRoute,\n  /**\n  * @param {?} route\n  * @return {?}\n  */\n  route => route && route.data);\n  /** @type {?} */\n  const selectUrl = createSelector(selectRouterState,\n  /**\n  * @param {?} routerState\n  * @return {?}\n  */\n  routerState => routerState && routerState.url);\n  return {\n    selectCurrentRoute,\n    selectFragment,\n    selectQueryParams,\n    selectQueryParam,\n    selectRouteParams,\n    selectRouteParam,\n    selectRouteData,\n    selectUrl\n  };\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: src/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: ngrx-router-store.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { DEFAULT_ROUTER_FEATURENAME, DefaultRouterStateSerializer, MinimalRouterStateSerializer, NavigationActionTiming, ROUTER_CANCEL, ROUTER_CONFIG, ROUTER_ERROR, ROUTER_NAVIGATED, ROUTER_NAVIGATION, ROUTER_REQUEST, RouterStateSerializer, StoreRouterConnectingModule, getSelectors, routerCancelAction, routerErrorAction, routerNavigatedAction, routerNavigationAction, routerReducer, routerRequestAction, _ROUTER_CONFIG as ɵa, _createRouterConfig as ɵb };\n\n//# sourceMappingURL=ngrx-router-store.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}